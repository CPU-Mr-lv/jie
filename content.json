{"meta":{"title":"文采呱呱","subtitle":"","description":"","author":"小杰","url":"https://cpu-mr-lv.github.io/jie.io","root":"/jie.io/"},"pages":[],"posts":[{"title":"h5语义化","slug":"h5语义化","date":"2020-10-28T14:38:57.000Z","updated":"2020-10-28T14:40:27.200Z","comments":true,"path":"2020/10/28/h5语义化/","link":"","permalink":"https://cpu-mr-lv.github.io/jie.io/2020/10/28/h5%E8%AF%AD%E4%B9%89%E5%8C%96/","excerpt":"","text":"什么是语义化？语义化就是用合理、正确的标签来展示内容，比如h1~h6定义标题。#特点 易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。方便其他设备解析，如盲人阅读器根据语义渲染网页有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。 #语义化标签结构 1、&lt;header&gt; &lt;header&gt;定义文档或者文档的部分区域的页眉，应作为介绍内容或者导航链接栏的容器。 在一个文档中，您可以定义多个&lt;header&gt;元素，但需要注意的是&lt;header&gt;元素不能作为&lt;address&gt;、&lt;footer&gt; 或 &lt;header&gt; 元素的子元素。 2、&lt;nav&gt; &lt;nav&gt;描述一个含有多个超链接的区域，该区域包含跳转到其他页面或页面内部其他部分的链接列表。 在一个文档中，可定义多个&lt;nav&gt;元素。 3、&lt;main&gt; &lt;main&gt; 定义文档的主要内容，该内容在文档中应当是独一无二的，不包含任何在文档中重复的内容，比如侧边栏，导航栏链接，版权信息，网站logo，搜索框（除非搜索框作为文档的主要功能）。 需要注意的是在一个文档中不能出现多个&lt;main&gt;标签。 4、&lt;article&gt; &lt;article&gt;元素表示文档、页面、应用或网站中的独立结构，是可独立分配的、可复用的结构，如在发布中，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件，或者其他独立的内容项目。 当&lt;article&gt;元素嵌套使用时，则该元素代表与外层元素有关的文章。例如，代表博客评论的&lt;article&gt;元素可嵌套在代表博客文章的&lt;article&gt;元素中。 5、&lt;aside&gt; &lt;aside&gt; 元素表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分且可以被单独的拆分出来而不会影响整体。通常表现为侧边栏或嵌入内容。 6、&lt;footer&gt; &lt;footer&gt;定义最近一个章节内容或者根节点元素的页脚。一个页脚通常包含该章节作者、版权数据或者与文档相关的链接等信息。 使用footer插入联系信息时，应在 footer 元素内使用 &lt;address&gt; 元素。 注意不能包含&lt;footer&gt;或者&lt;header&gt; 7、&lt;section&gt; &lt;section&gt;表示文档中的一个区域（或节），比如，内容中的一个专题组。","categories":[],"tags":[]},{"title":"盒模型","slug":"盒模型","date":"2020-10-28T14:36:30.000Z","updated":"2020-10-28T14:37:10.381Z","comments":true,"path":"2020/10/28/盒模型/","link":"","permalink":"https://cpu-mr-lv.github.io/jie.io/2020/10/28/%E7%9B%92%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"盒模型指什么？ Margin(外边距) - 清除边框外的区域，外边距是透明的。Border(边框) - 围绕在内边距和内容外的边框。Padding(内边距) - 清除内容周围的区域，内边距是透明的。Content(内容) - 盒子的内容，显示文本和图像。","categories":[],"tags":[]},{"title":"cookies和session的区别","slug":"cookie","date":"2020-10-28T14:34:14.000Z","updated":"2020-10-28T14:34:56.305Z","comments":true,"path":"2020/10/28/cookie/","link":"","permalink":"https://cpu-mr-lv.github.io/jie.io/2020/10/28/cookie/","excerpt":"","text":"1、数据bai存放du位置不同： cookie数据存放在客户的zhi浏览器上，session数据放在服务器上。 2、安全程度不dao同： cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,考虑到安全应当使用session。 3、性能使用程度不同： session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。 4、数据存储大小不同： 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，而session则存储与服务端，浏览器对其没有限制。","categories":[],"tags":[]},{"title":"Vue Router","slug":"Vue-Router","date":"2020-10-28T14:30:26.000Z","updated":"2020-10-28T14:33:26.770Z","comments":true,"path":"2020/10/28/Vue-Router/","link":"","permalink":"https://cpu-mr-lv.github.io/jie.io/2020/10/28/Vue-Router/","excerpt":"","text":"##vue router是什么？ Vue Router 是 Vue.js 官方的路由管理器。实际上就是可以理解为指向，即在页面上点击一个按钮需要跳转到对应的页面，这就是路由跳转； vue router的安装npm install vue-cli","categories":[],"tags":[]},{"title":"vue","slug":"vue","date":"2020-10-28T14:25:58.000Z","updated":"2020-10-28T14:29:16.829Z","comments":true,"path":"2020/10/28/vue/","link":"","permalink":"https://cpu-mr-lv.github.io/jie.io/2020/10/28/vue/","excerpt":"","text":"##什么是vue？ Vue 是一套用于构建用户界面的渐进式框架，项目如果需要更换框架，则需要重新架构整个项目 ##Vue作为前端框架的特点是什么？ 1.构建用户界面，只需要关系view层2.简单易学，轻量快速3.渐进式框架 ##vue的两大核心是什么？ 1.响应式的数据绑定：当数据发生改变，视图可以自动更新，可以不用关心dom操作，而专心数据操作2.可组合的视图组件：把视图按照功能切分成若干基本单元，组件可以一级一级组合整个应用形成倒置组件树，可维护，可重用，可测试","categories":[],"tags":[]},{"title":"promise","slug":"promise","date":"2020-10-28T13:35:53.000Z","updated":"2020-10-28T13:41:48.174Z","comments":true,"path":"2020/10/28/promise/","link":"","permalink":"https://cpu-mr-lv.github.io/jie.io/2020/10/28/promise/","excerpt":"","text":"##promise是什么？ 1、主要用于异步计算2、可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果3、可以在对象之间传递和操作promise，帮助我们处理队列 ##promise promise是一个对象，对象和函数的区别就是对象可以保存状态，函数不可以（闭包除外）并未剥夺函数return的能力，因此无需层层传递callback，进行回调获取数据代码风格，容易理解，便于维护多个异步等待合并便于解决 ##promise详解 resolve作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。promise有三个状态：1、pending[待定]初始状态2、fulfilled[实现]操作成功3、rejected[被否决]操作失败当promise状态发生改变，就会触发then()里的响应函数处理后续步骤；promise状态一经改变，不会再变。Promise对象的状态改变，只有两种可能：从pending变为fulfilled从pending变为rejected。这两种情况只要发生，状态就凝固了，不会再变了。 ##示例一 new Promise(resolve &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; resolve(&#39;hello&#39;) &#125;, 2000)&#125;).then(res &#x3D;&gt; &#123; console.log(res)&#125;) ##分两次，顺序执行 new Promise(resolve &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; resolve(&#39;hello&#39;) &#125;, 2000) &#125;).then(val &#x3D;&gt; &#123; console.log(val) &#x2F;&#x2F; 参数val &#x3D; &#39;hello&#39; return new Promise(resolve &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; resolve(&#39;world&#39;) &#125;, 2000) &#125;) &#125;).then(val &#x3D;&gt; &#123; console.log(val) &#x2F;&#x2F; 参数val &#x3D; &#39;world&#39; &#125;) ##promise完成后then() let pro &#x3D; new Promise(resolve &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; resolve(&#39;hello world&#39;) &#125;, 2000) &#125;) setTimeout(() &#x3D;&gt; &#123; pro.then(value &#x3D;&gt; &#123; console.log(value) &#x2F;&#x2F; hello world &#125;) &#125;, 2000) ##.then() .then() 1、接收两个函数作为参数，分别代表fulfilled（成功）和rejected（失败） 2、.then()返回一个新的Promise实例，所以它可以链式调用 3、当前面的Promise状态改变时，.then()根据其最终状态，选择特定的状态响应函数执行 4、状态响应函数可以返回新的promise，或其他值，不返回值也可以我们可以认为它返回了一个null； 5、如果返回新的promise，那么下一级.then()会在新的promise状态改变之后执行 6、如果返回其他任何值，则会立即执行下一级.then()","categories":[],"tags":[]},{"title":"axios","slug":"My-Gallery","date":"2020-10-28T13:14:20.000Z","updated":"2020-10-29T15:48:21.582Z","comments":true,"path":"2020/10/28/My-Gallery/","link":"","permalink":"https://cpu-mr-lv.github.io/jie.io/2020/10/28/My-Gallery/","excerpt":"","text":"##Axios是什么？ axios 是基于promise的http库 ##axios用在什么场景？ 像Vue、React、Node等项目就可以使用Axios ##Axios特性 1、可以在浏览器中发送 XMLHttpRequests2、可以在 node.js 发送 http 请求3、支持 Promise API4、拦截请求和响应5、转换请求数据和响应数据6、能够取消请求7、自动转换 JSON 数据8、客户端支持保护安全免受 XSRF 攻击 ##Axios如何使用？ npm install axios","categories":[],"tags":[]},{"title":"vue过场动画","slug":"zi","date":"2020-10-26T15:12:12.000Z","updated":"2020-10-26T15:32:19.207Z","comments":true,"path":"2020/10/26/zi/","link":"","permalink":"https://cpu-mr-lv.github.io/jie.io/2020/10/26/zi/","excerpt":"","text":"vue过场动画&lt;template&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &lt;transition :enter-active-class&#x3D;&quot;enterTransition&quot; :leave-active-class&#x3D;&quot;leaveTransition&quot;&gt; &lt;keep-alive&gt; &lt;router-view class&#x3D;&quot;routeView&quot; &#x2F;&gt; &lt;&#x2F;keep-alive&gt; &lt;&#x2F;transition&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import myhea from &quot;@&#x2F;components&#x2F;hea.vue&quot;;import myfooter from &quot;@&#x2F;components&#x2F;footer.vue&quot;;export default &#123; name: &quot;App&quot;, components: &#123; myhea, myfooter, &#125;, data() &#123; return &#123; enterTransition: &quot;animate__animated animate__fadeIn&quot;, leaveTransition: &quot;animate__animated animate__fadeOut&quot;, &#125;; &#125;, watch: &#123; $route(to, from) &#123; let toDepth &#x3D; to.meta.depth; let fromDepth &#x3D; from.meta.depth; if (fromDepth &gt; toDepth) &#123; this.enterTransition &#x3D; &quot;animate__animated animate__fadeInLeft&quot;; this.leaveTransition &#x3D; &quot;animate__animated animate__fadeOutRight&quot;; &#125; else if (fromDepth &lt; toDepth) &#123; this.enterTransition &#x3D; &quot;animate__animated animate__fadeInRight&quot;; this.leaveTransition &#x3D; &quot;animate__animated animate__fadeOutLeft&quot;; &#125; else &#123; this.enterTransition &#x3D; &quot;animate__animated animate__fadeIn&quot;; this.leaveTransition &#x3D; &quot;animate__animated animate__fadeOut&quot;; &#125; &#125;, &#125;,&#125;;&lt;&#x2F;script&gt;&lt;style&gt;.routeView &#123; position: absolute; left: 0; right: 0; top: 0; bottom: 0;&#125;* &#123; margin: 0px; padding: 0px;&#125;#app &#123; min-width: 20rem; font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50;&#125;&lt;&#x2F;style&gt;$ npm install animate.css --save","categories":[],"tags":[]},{"title":"移动端自适应","slug":"移动端自适应","date":"2020-10-26T14:06:56.000Z","updated":"2020-10-26T14:28:52.382Z","comments":true,"path":"2020/10/26/移动端自适应/","link":"","permalink":"https://cpu-mr-lv.github.io/jie.io/2020/10/26/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%87%AA%E9%80%82%E5%BA%94/","excerpt":"","text":"移动端自适应&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0,maximum-scale&#x3D;1.0,minimum-scale&#x3D;1.0,user-scalable&#x3D;no&quot;&gt; width=device-width width为设置layout viewport 的宽度，为一个正整数，”width-device”表示宽度是设备屏幕的宽度initial-scale=1.0 initial-scale为设置页面的初始缩放值，可以是一个带小数的数字，1.0就是占网页的100%minimum-scale=1.0 表示最小的缩放比例maximum-scale=1.0 表示最大的缩放比例user-scalable=no 表示用户是否可以调整缩放比例，值为”no”或”yes”","categories":[],"tags":[]},{"title":"文采呱呱的新博客","slug":"My-New-Post","date":"2020-10-25T11:32:35.000Z","updated":"2020-10-25T11:55:53.871Z","comments":true,"path":"2020/10/25/My-New-Post/","link":"","permalink":"https://cpu-mr-lv.github.io/jie.io/2020/10/25/My-New-Post/","excerpt":"","text":"由博客园换新家啦，知识持续更新中…","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-10-25T10:00:45.908Z","updated":"2020-10-25T10:00:45.908Z","comments":true,"path":"2020/10/25/hello-world/","link":"","permalink":"https://cpu-mr-lv.github.io/jie.io/2020/10/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}